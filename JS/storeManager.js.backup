console.log("Module loaded: storeManager (Mapbox GL JS)");

// ============================================================================
// NEW PIN MANAGEMENT FUNCTIONS
// ============================================================================
// 
// saveUserPinsToSupabase(newPin, userId) - Saves a single pin to Supabase
// addNewPinToSupabase(pinData, userId) - Adds a new pin to Supabase
// loadUserPinsFromSupabase(userId) - Loads all pins for a user from Supabase
// 
// These functions use UPSERT with onConflict: 'user_id' to ensure:
// - One row per user
// - Pins stored as JSON array in the 'pins' column
// - Automatic row creation for new users
// - No duplicate rows
// ============================================================================

// --- Helper function to check if user_pins table exists ---
async function checkUserPinsTableExists() {
  try {
    // Try a simple query to see if the table exists
    const { data, error } = await supabase
      .from('user_pins')
      .select('user_id')
      .limit(1);
    
    if (error) {
      if (error.code === 'PGRST116' || error.message.includes('relation') || error.message.includes('does not exist')) {
        return false; // Table doesn't exist
      }
      throw error; // Other error
    }
    
    return true; // Table exists
  } catch (error) {
    console.log('[Pins] Error checking if user_pins table exists:', error.message);
    return false;
  }
}

// --- Helper function to create user_pins table if it doesn't exist ---
async function createUserPinsTable(userId) {
  try {
    console.log('[Pins] Attempting to create user_pins table...');
    
    // First check if table exists
    const tableExists = await checkUserPinsTableExists();
    if (tableExists) {
      console.log('[Pins] user_pins table already exists');
      return true;
    }
    
    // Try to create the table using Supabase's SQL execution
    const { error } = await supabase.rpc('create_user_pins_table', { user_id: userId });
    
    if (error) {
      console.log('[Pins] RPC function not available, trying direct SQL...');
      
      // Fallback: try to create table directly (this might not work due to RLS)
      const { error: sqlError } = await supabase
        .from('user_pins')
        .insert([{
          user_id: userId,
          pins: '[]',
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }]);
      
      if (sqlError) {
        console.log('[Pins] Could not create table or insert initial record:', sqlError.message);
        console.log('[Pins] This is expected if the table structure is different or RLS is blocking access');
        return false;
      }
    }
    
    console.log('[Pins] user_pins table/record created successfully');
    return true;
  } catch (error) {
    console.log('[Pins] Error creating user_pins table:', error.message);
    return false;
  }
}

// --- Debug function to check Supabase setup ---
export async function debugSupabaseSetup() {
  try {
    console.log('[Debug] Checking Supabase setup...');
    
    // Check if supabase client is available
    if (!supabase) {
      console.log('[Debug] ❌ Supabase client not available');
      return { status: 'error', message: 'Supabase client not available' };
    }
    
    // Check if user is authenticated
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError) {
      console.log('[Debug] ❌ Auth error:', authError.message);
      return { status: 'error', message: 'Auth error: ' + authError.message };
    }
    
    if (!user) {
      console.log('[Debug] ❌ No user authenticated');
      return { status: 'error', message: 'No user authenticated' };
    }
    
    console.log('[Debug] ✅ User authenticated:', user.id);
    
    // Check if user_pins table exists
    const tableExists = await checkUserPinsTableExists();
    console.log('[Debug] Table exists:', tableExists);
    
    // Try to query the table
    if (tableExists) {
      try {
        const { data, error } = await supabase
          .from('user_pins')
          .select('*')
          .eq('user_id', user.id);
        
        if (error) {
          console.log('[Debug] ❌ Query error:', error.message);
          return { 
            status: 'partial', 
            message: 'Table exists but query failed: ' + error.message,
            tableExists: true,
            userId: user.id
          };
        }
        
        console.log('[Debug] ✅ Query successful, data:', data);
        return { 
          status: 'success', 
          message: 'Supabase setup working correctly',
          tableExists: true,
          userId: user.id,
          data: data
        };
      } catch (queryError) {
        console.log('[Debug] ❌ Query exception:', queryError.message);
        return { 
          status: 'error', 
          message: 'Query exception: ' + queryError.message,
          tableExists: true,
          userId: user.id
        };
      }
    } else {
      console.log('[Debug] ⚠️ user_pins table does not exist');
      return { 
        status: 'warning', 
        message: 'user_pins table does not exist',
        tableExists: false,
        userId: user.id
      };
    }
  } catch (error) {
    console.log('[Debug] ❌ Debug function error:', error.message);
    return { status: 'error', message: 'Debug function error: ' + error.message };
  }
}

// --- Pins ---
export async function saveUserPinsToSupabase(newPin, userId) {
  try {
    // 1. Fetch existing pin array (or empty)
    const { data: existing, error: fetchError } = await supabase
      .from('user_pins')
      .select('pins')
      .eq('user_id', userId)
      .single();

    if (fetchError && fetchError.code !== 'PGRST116') {
      // If error and not "row not found", throw
      throw fetchError;
    }

    // Handle both string and array formats for backward compatibility
    let currentPins;
    if (typeof existing?.pins === 'string') {
      try {
        currentPins = JSON.parse(existing.pins);
      } catch (parseError) {
        console.error('[Pins] Failed to parse existing pins string:', parseError.message);
        currentPins = [];
      }
    } else if (Array.isArray(existing?.pins)) {
      currentPins = [...existing.pins]; // Create a copy
    } else {
      currentPins = [];
    }

    // 2. Append the new pin
    currentPins.push(newPin);

    // 3. Save updated pins array back via UPSERT
    const { error: upsertError } = await supabase
      .from('user_pins')
      .upsert(
        { user_id: userId, pins: currentPins },
        { onConflict: 'user_id' }
      );

    if (upsertError) {
      console.error('[Pins] Supabase UPSERT failed:', upsertError.message);
      return false;
    }

    console.log('[Pins] Saved pin to Supabase (array updated)');
    return true;

  } catch (err) {
    console.error('[Pins] Unexpected save error:', err.message);
    return false;
  }
}

// Helper function to add a single new pin
export async function addNewPinToSupabase(pinData, userId) {
  try {
    const newPin = {
      name: pinData.name,
      lat: pinData.lat,
      lng: pinData.lng,
      created_at: new Date().toISOString()
    };
    
    const success = await saveUserPinsToSupabase(newPin, userId);
    if (success) {
      console.log(`[Pins] Successfully added new pin "${pinData.name}" to Supabase`);
      return true;
    } else {
      console.error(`[Pins] Failed to add new pin "${pinData.name}" to Supabase`);
      return false;
    }
  } catch (error) {
    console.error('[Pins] Error adding new pin to Supabase:', error.message);
    return false;
  }
}

// Function to load user pins from Supabase
export async function loadUserPinsFromSupabase(userId) {
  try {
    console.log('[Pins] Loading pins from Supabase for user:', userId);
    
    // Query the user_pins table
    const { data, error } = await supabase
      .from('user_pins')
      .select('pins')
      .eq('user_id', userId)
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        // Row not found - create empty row
        console.log('[Pins] No existing row found, creating empty one');
        const { error: insertError } = await supabase
          .from('user_pins')
          .insert([{
            user_id: userId,
            pins: [],
            updated_at: new Date().toISOString()
          }]);
        
        if (insertError) {
          console.error('[Pins] Failed to create empty row:', insertError.message);
          return [];
        }
        
        console.log('[Pins] Created empty row for user');
        return [];
      } else {
        console.error('[Pins] Error loading pins from Supabase:', error.message);
        return [];
      }
    }

    if (!data || !data.pins) {
      console.log('[Pins] No pins data found, returning empty array');
      return [];
    }

    // Handle both string and array formats for backward compatibility
    let pins;
    if (typeof data.pins === 'string') {
      try {
        pins = JSON.parse(data.pins);
      } catch (parseError) {
        console.error('[Pins] Failed to parse pins string:', parseError.message);
        return [];
      }
    } else if (Array.isArray(data.pins)) {
      pins = data.pins;
    } else {
      console.warn('[Pins] Unexpected pins data format:', typeof data.pins);
      return [];
    }

    console.log('[Pins] Successfully loaded pins from Supabase:', pins.length);
    return pins;

  } catch (error) {
    console.error('[Pins] Unexpected error loading pins from Supabase:', error.message);
    return [];
  }
}

export async function savePins(customPins) {
  const saveData = customPins.map(pin => ({
    name: pin.name,
    lat: pin.lat,
    lng: pin.lng
  }));
  
  // Save to localStorage
  localStorage.setItem('witd_pins', JSON.stringify(saveData));
  
  // Try to save to Supabase if user is authenticated
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (user) {
      // Save the entire array of pins to Supabase
      const { error: upsertError } = await supabase
        .from('user_pins')
        .upsert({
          user_id: user.id,
          pins: saveData,
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'user_id'
        });
      
      if (upsertError) {
        console.error('[Pins] Supabase UPSERT failed:', upsertError.message);
        console.log('[Pins] Using localStorage fallback');
      } else {
        console.log('[Pins] Successfully saved all pins to Supabase:', saveData.length, 'pins');
      }
    }
  } catch (error) {
    console.log('[Pins] Supabase save failed, using localStorage only:', error.message);
  }
}

export async function loadPins(map, customPins, attachPopupActions) {
  // 🔧 Safe JSON.parse with error handling
  let savedPins = [];
  try {
    savedPins = JSON.parse(localStorage.getItem('witd_pins') || '[]') || [];
  } catch (err) {
    console.error('[Pins] Failed to parse localStorage pins:', err);
    savedPins = [];
  }
  
  // Try to load from Supabase if user is authenticated
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (user) {
      // First check if the user_pins table exists by trying to query it
      try {
        const { data, error } = await supabase
          .from('user_pins')
          .select('pins')
          .eq('user_id', user.id)
          .single();

        if (error) {
          // Check if it's a table not found error
          if (error.code === 'PGRST116' || error.message.includes('relation') || error.message.includes('does not exist')) {
            console.log('[Pins] user_pins table does not exist, creating it...');
            await createUserPinsTable(user.id);
            // Retry the query after table creation
            const { data: retryData, error: retryError } = await supabase
              .from('user_pins')
              .select('pins')
              .eq('user_id', user.id)
              .single();
            
            if (retryError) {
              throw retryError;
            }
            
            if (retryData?.pins) {
              try {
                savedPins = JSON.parse(retryData.pins);
                console.log('[Pins] Loaded from Supabase after table creation:', savedPins.length, 'pins');
                localStorage.setItem('witd_pins', JSON.stringify(savedPins));
              } catch (parseError) {
                console.error('[Pins] Failed to parse Supabase pins:', parseError);
              }
            }
          } else {
            throw error;
          }
        } else if (data?.pins) {
          try {
            // Handle both old string format and new array format
            let pinsData;
            if (typeof data.pins === 'string') {
              pinsData = JSON.parse(data.pins);
            } else if (Array.isArray(data.pins)) {
              pinsData = data.pins;
            } else {
              console.warn('[Pins] Unexpected pins data format:', typeof data.pins);
              pinsData = [];
            }
            
            savedPins = pinsData;
            console.log('[Pins] Loaded from Supabase:', savedPins.length, 'pins');
            
            // Update localStorage with Supabase data
            localStorage.setItem('witd_pins', JSON.stringify(savedPins));
          } catch (parseError) {
            console.error('[Pins] Failed to parse Supabase pins:', parseError);
            // Keep using localStorage data if Supabase data is corrupt
          }
        } else if (!data) {
          // No existing row found for user — create empty one
          console.log('[Pins] No existing row found for user — creating empty one');
          try {
            const { error: insertError } = await supabase.from('user_pins').insert([
              {
                user_id: user.id,
                pins: [],
                updated_at: new Date().toISOString()
              }
            ]);
            
            if (insertError) {
              console.error('[Pins] Failed to create empty row:', insertError.message);
            } else {
              console.log('[Pins] Created empty row for user');
              savedPins = []; // Set to empty array since we just created an empty row
            }
          } catch (insertException) {
            console.error('[Pins] Exception creating empty row:', insertException.message);
          }
        }
      } catch (tableError) {
        console.log('[Pins] Table operation failed, using localStorage:', tableError.message);
      }
    }
  } catch (error) {
    console.log('[Pins] Supabase load failed, using localStorage:', error.message);
  }
  
  // Convert pins to the same format as normal pins and add them to the map
  savedPins.forEach((data, index) => {
    try {
      // Create a unique ID for each pin
      const pinId = `custom-pin-${index}`;
      const labelId = `custom-label-${index}`;
      
      // Create Mapbox marker with the same styling as normal pins
      const marker = new mapboxgl.Marker({
        color: '#ff6600',
        scale: 1.2
      })
      .setLngLat([data.lng, data.lat])
      .addTo(map);
        map.addSource(pinId, {
          type: 'geojson',
          data: {
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [data.lng, data.lat] // Mapbox uses [lng, lat] order
            },
            properties: {
              name: data.name,
              pinId: pinId
            }
          }
        });
        
        // Add pin marker layer
        map.addLayer({
          id: pinId,
          type: 'symbol',
          source: pinId,
          layout: {
            'icon-image': 'RedMarkerPin', // Use existing pin icon
            'icon-size': 0.05,
            'icon-allow-overlap': true
          }
        });
        
        // Add label layer
        map.addLayer({
          id: labelId,
          type: 'symbol',
          source: pinId,
          layout: {
            'text-field': data.name,
            'text-size': 12,
            'text-offset': [0, -2],
            'text-anchor': 'bottom',
            'text-allow-overlap': true
          },
          paint: {
            'text-color': '#333',
            'text-halo-color': '#fff',
            'text-halo-width': 2
          }
        });
        
        // Create pin object for management
        const pin = { 
          id: pinId, 
          labelId: labelId,
          name: data.name, 
          lat: data.lat, 
          lng: data.lng,
          source: pinId
        };
        customPins.push(pin);
        
        // Add click event to the pin
        map.on('click', pinId, (e) => {
          e.preventDefault();
          
          // Create popup content
          const popupContent = document.createElement('div');
          popupContent.innerHTML = `
            <b>${data.name}</b><br>
            Lat: ${data.lat.toFixed(5)}<br>
            Lon: ${data.lng.toFixed(5)}<br><br>
            <button class="rename-btn">✏️ Rename</button>
            <button class="delete-btn">🗑️ Delete</button>
            <button class="journal-btn">📓 Send to Journal</button>
          `;
          
          // Add event listeners to buttons
          const renameBtn = popupContent.querySelector('.rename-btn');
          const deleteBtn = popupContent.querySelector('.delete-btn');
          const journalBtn = popupContent.querySelector('.journal-btn');
          
          renameBtn.addEventListener('click', () => {
            if (attachPopupActions && attachPopupActions.reopenRename) {
              attachPopupActions.reopenRename(pin, pin);
            }
          });
          
          deleteBtn.addEventListener('click', () => {
            // Remove pin from map
            if (map.getLayer(pinId)) map.removeLayer(pinId);
            if (map.getLayer(labelId)) map.removeLayer(labelId);
            if (map.getSource(pinId)) map.removeSource(pinId);
            
            // Remove from customPins array
            const pinIndex = customPins.indexOf(pin);
            if (pinIndex > -1) customPins.splice(pinIndex, 1);
            
            // Save updated pins
            savePins(customPins);
          });
          
          journalBtn.addEventListener('click', () => {
            if (typeof initJournal === "function") {
              initJournal();
              setTimeout(() => {
                const journalModal = document.getElementById('journalModal');
                const journalBtn = document.getElementById('toolbarJournalBtn');
                if (typeof openPopupAboveButton === 'function') {
                  openPopupAboveButton(journalModal, journalBtn, true);
                }
    
                const titleEl = document.getElementById('journalTitle');
                const coordsEl = document.getElementById('journalCoords');
                const noteEl = document.getElementById('journalNote');
    
                if (titleEl && coordsEl && noteEl) {
                  titleEl.value = pin.name;
                  coordsEl.value = `${pin.lat.toFixed(5)}, ${pin.lng.toFixed(5)}`;
                  noteEl.focus();
                }
    
                if (typeof openPopup !== 'undefined' && typeof openButton !== 'undefined' && typeof positionPopup === 'function') {
                  positionPopup(openPopup, openButton, openAlignRight);
                }
              }, 50);
            } else {
              alert("Journal module not loaded.");
            }
          });
          
          // Show popup
          new mapboxgl.Popup()
            .setLngLat([data.lng, data.lat])
            .setDOMContent(popupContent)
            .addTo(map);
        });
        
        console.log(`[Pins] Added pin: ${data.name} at [${data.lat}, ${data.lng}]`);
      }
    } catch (error) {
      console.error(`[Pins] Error adding pin ${data.name}:`, error);
    }
  });
}

// Helper function to create label element (same as in pinManager.js)
function createLabelElement(name) {
  const labelDiv = document.createElement('div');
  labelDiv.className = 'marker-text-box';
  labelDiv.innerHTML = `<div class="label-inner">${name}</div>`;
  return labelDiv;
}

// Helper function to bind popup actions (same as in pinManager.js)
function bindPopupActions(marker, pin) {
  const popup = marker.getPopup();
  const popupElement = popup.getElement();
  
  if (!popupElement) return;
  
  const renameBtn = popupElement.querySelector('.rename-btn');
  const deleteBtn = popupElement.querySelector('.delete-btn');
  const journalBtn = popupElement.querySelector('.journal-btn');
  
  if (renameBtn) {
    renameBtn.addEventListener('click', () => {
      // For now, just log - this will be handled by the main pinManager
      console.log('[Pins] Rename requested for pin:', pin.name);
    });
  }
  
  if (deleteBtn) {
    deleteBtn.addEventListener('click', async () => {
      // Remove from map
      if (pin.marker && pin.marker.element) {
        pin.marker.element.remove();
      }
      if (pin.labelMarker && pin.labelMarker.element) {
        pin.labelMarker.element.remove();
      }
      
      // Remove from customPins array
      const pinIndex = customPins.indexOf(pin);
      if (pinIndex > -1) {
        customPins.splice(pinIndex, 1);
      }
      
      // Save updated pins
      await savePins(customPins);
    });
  }
  
  if (journalBtn) {
    journalBtn.addEventListener('click', () => {
      // Send pin to journal
      if (typeof window.initJournal === 'function') {
        // Get the journal button to simulate a click
        const journalBtn = document.getElementById('toolbarJournalBtn');
        if (journalBtn) {
          // Store pin data for the journal
          window.pinForJournal = {
            title: `Pin: ${pin.name}`,
            coords: `${pin.lat.toFixed(5)}, ${pin.lng.toFixed(5)}`,
            note: `Location marked on map: ${pin.name}`
          };
          
          // Simulate clicking the journal button to open it normally
          journalBtn.click();
          
          // Pre-fill the form after the modal opens
          setTimeout(() => {
            const titleInput = document.getElementById('journalTitle');
            const coordsInput = document.getElementById('journalCoords');
            const noteInput = document.getElementById('journalNote');
            
            if (titleInput && window.pinForJournal) titleInput.value = window.pinForJournal.title;
            if (coordsInput && window.pinForJournal) coordsInput.value = window.pinForJournal.coords;
            if (noteInput && window.pinForJournal) noteInput.value = window.pinForJournal.note;
            
            // Focus on the note input
            if (noteInput) noteInput.focus();
            
            // Clear the stored data
            delete window.pinForJournal;
          }, 200);
        }
      } else {
        console.error('Journal module not available');
        alert('Journal module not loaded. Please refresh the page.');
      }
    });
  }
}

// --- Tracks ---
export function saveTracks(drawnTracks) {
  const saveData = drawnTracks.map(track => ({
    coords: track.points || [],
    name: track.name || '',
    markerTypes: track.markerTypes || []
  }));
  localStorage.setItem('witd_tracks', JSON.stringify(saveData));
}

export function loadTracks(map, drawnTracks, drawTrackLabel) {
  const savedTracks = JSON.parse(localStorage.getItem('witd_tracks') || '[]');
  savedTracks.forEach((data, index) => {
    if (data.coords && data.coords.length >= 2) {
      try {
        const trackId = `custom-track-${index}`;
        
        // Add track source
        if (!map.getSource(trackId)) {
          map.addSource(trackId, {
            type: 'geojson',
            data: {
              type: 'Feature',
              geometry: {
                type: 'LineString',
                coordinates: data.coords
              },
              properties: {
                name: data.name
              }
            }
          });
          
          // Add track line layer
          map.addLayer({
            id: trackId,
            type: 'line',
            source: trackId,
            layout: {
              'line-join': 'round',
              'line-cap': 'round'
            },
            paint: {
              'line-color': '#ff0000',
              'line-width': 3
            }
          });
          
          // Create track object for management
          const track = { 
            id: trackId, 
            coords: data.coords, 
            markerTypes: data.markerTypes, 
            name: data.name,
            source: trackId
          };
          drawnTracks.push(track);
          
          // Call drawTrackLabel if function exists
          if (typeof drawTrackLabel === 'function') {
            drawTrackLabel(track, data.name, data.markerTypes);
          }
          
          console.log(`[Tracks] Added track: ${data.name} with ${data.coords.length} points`);
        }
      } catch (error) {
        console.error(`[Tracks] Error adding track ${data.name}:`, error);
      }
    } else {
      console.warn('Skipped empty or invalid track:', data);
    }
  });
}

// --- Weather Marker ---
// (Removed: no longer saving/loading weather marker in localStorage)

// --- GPX ---
export function saveGpxFiles(gpxFiles) {
  localStorage.setItem('witd_gpx_files', JSON.stringify(gpxFiles));
}

export function loadGpxFiles(map, gpxFiles, addGpxToMap) {
  const saved = JSON.parse(localStorage.getItem('witd_gpx_files') || '[]');
  saved.forEach(file => {
    addGpxToMap(file.name, file.content);
    gpxFiles.push(file);
  });
}

// --- Clear All ---
export function clearAll() {
  localStorage.removeItem('witd_pins');
  localStorage.removeItem('witd_tracks');
  localStorage.removeItem('witd_gpx_files');
}

// --- Global debug function for browser console ---
window.debugSupabasePins = async function() {
  console.log('🔍 Debugging Supabase pins setup...');
  
  try {
    // Import the debug function
    const { debugSupabaseSetup } = await import('./storeManager.js');
    const result = await debugSupabaseSetup();
    console.log('🔍 Debug result:', result);
    return result;
  } catch (error) {
    console.log('🔍 Error importing debug function:', error.message);
    
    // Fallback: try to call it directly if it's already loaded
    if (typeof window.debugSupabaseSetup === 'function') {
      const result = await window.debugSupabaseSetup();
      console.log('🔍 Debug result (direct call):', result);
      return result;
    } else {
      console.log('🔍 Debug function not available');
      return { status: 'error', message: 'Debug function not available' };
    }
  }
};

console.log('🔍 Debug function available: window.debugSupabasePins()');

// --- Simple global debug function ---
window.debugSupabaseSimple = async function() {
  console.log('🔍 Simple Supabase debug...');
  
  try {
    // Check if supabase is available
    if (typeof supabase === 'undefined') {
      console.log('❌ Supabase client not available');
      return { error: 'Supabase client not available' };
    }
    
    // Check if user is authenticated
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError) {
      console.log('❌ Auth error:', authError.message);
      return { error: 'Auth error: ' + authError.message };
    }
    
    if (!user) {
      console.log('❌ No user authenticated');
      return { error: 'No user authenticated' };
    }
    
    console.log('✅ User authenticated:', user.id);
    
    // Try to query user_pins table
    try {
      const { data, error } = await supabase
        .from('user_pins')
        .select('*')
        .eq('user_id', user.id);
      
      if (error) {
        console.log('❌ Query error:', error.message);
        return { 
          user: user.id, 
          error: error.message, 
          errorCode: error.code 
        };
      }
      
      console.log('✅ Query successful, data:', data);
      return { 
        user: user.id, 
        success: true, 
        data: data 
      };
    } catch (queryError) {
      console.log('❌ Query exception:', queryError.message);
      return { 
        user: user.id, 
        error: 'Query exception: ' + queryError.message 
      };
    }
  } catch (error) {
    console.log('❌ Debug function error:', error.message);
    return { error: 'Debug function error: ' + error.message };
  }
};

console.log('🔍 Simple debug function available: window.debugSupabaseSimple()');
